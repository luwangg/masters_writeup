\chapter{FPGA Firmware}
\label{ch:firmware-design}
\setsvg{svgpath=./img/firmware/}
\graphicspath{{./img/firmware/}}

This Chapter details the design, implementation and testing of the FPGA firmware. Testing involves both simulating using data path as well putting the firmware on the physical FPGA, sending input RF signals to it and analysing the output of the FPGA's DSP.

\section{Hardware Specifications}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{roach-photo}
  \caption{Photo of the ROACH board and ADCs. Bottom: Two Atmel AT84AD001B dual ADC cards with SMA connectors going in to them and connected via Z-DOK to the ROACH board. Bottom right: ADC clock synthesiser feeding into power splitter which in turn clocks each ADC board in phase. Top: main ROACH board. The Virtex-5 is under the blue fan. To its left is the ROACH's DRAM module. To the right of the fan is the PowerPC with its DRAM module.}
  \label{fig:firmware:roach-photo}
\end{figure}

As discussed in the user requirements, the FPGA processing board that should be use is the same which is used by the SKA: the Reconfigurable Open Architecture Computing Hardware (ROACH)\footnote{\url{https://casper.berkeley.edu/wiki/ROACH}} board. This board has a Xilinx Virtex-5 FPGA on it, with connectors for Z-DOK+ cards which will be used for ADCs and a DDR2 DRAM connector for high volume\footnote{Compared to the Virtex-5's on-chip storage} data storage. There is a PowerPC subsystem on the ROACH running Linux which provides a 1 Gbps Ethernet interface for programming and data readout from the memory of the FPGA. The PowerPC runs a daemon called tcpborphserver which speaks the KATCP protocol used to interact with the ROACH. There are other blocks on the ROACH board as well, but the ones listed here will be the ones utilised in this project.

There are various ADC cards compatible with the ROACH. The ones which were made available for this project are iADC cards. Each card has an Atmel/e2V AT84AD001B 8-bit dual ADC chip on it. It's designed for I/Q sampling but can be configured to sample both channels in phase; exactly what's needed here. The clock speed can be up to \SI{1}{\giga\hertz} and must be externally supplied. The ADC feeds the clock signal through to the FPGA along with the sampled data with a demux factor of 4:1 meaning that for every 4 ADC clock cycles and 4 samples, the FPGA gets one clock cycle with all 4 samples on the ADC data bus. This implies that the FPGA will run at exactly a quarter of the speed the ADC runs at, and needs to be able to handle 4 samples per channel times 4 channels = 16 samples every clock cycle.

The clock source is a Valon 5007 dual synthesiser which is USB programmable from \SI{137}{\mega\hertz} to \SI{4400}{\mega\hertz}. Both ADCs need to be clocked exactly in phase so the Valon is fed into a Mini-Circuits ZESC2-11+ power splitter which has a phase imbalance of below \SI{0.1}{\degree}.

The ROACH board with connected ADCs is shown in \Cref{fig:firmware:roach-photo}. All of the components are in a metal case for RF shielding, although the cover has been removed for the photo.


\section{Firmware Development Toolchain}
There are a few components necessary to get development for the ROACH working. They're briefly listed here and detailed more in Appendix XYZ123.\\

Xilinx ISE 14.7 is needed for synthesising (compiling) HDL files to FPGA bitfiles. This proprietary tools is maintained by Xilinx and made available through the SKA. As well as this key task of compilation it also has peripheral tools for debugging and optimisation which proved useful for getting the design to meet timing. More info in Appendix XYZ123. Although it also works on Debian/Ubuntu systems, ISE is most stable and only officially supported for RHEL. As such as CentOS system was used for FPGA development work as it's mostly the same as RHEL at the binary interface level.\\

Matlab R2012B with Simulink was installed, along  with the mlib-devel plugin. The majority of the design work for ROACH done in this project is done at the block diagram level in Simulink. There is a plugin called mlib-devel which defines the Simulink interface for the Xilinx cores, as well as containing HDL code for ROACH specific hardware such as ADC cards, DRAM interface and PowerPC control bus. This naturally includes the net definitions for the components on the ROACH board.

The mlib-devel plugin was originally created by the CASPER, now contributed to extensively by the SKA. It contains a multitude of highly useful DSP blocks which are built on top of the Xilinx cores which can be wired up in Simulink. These include range from relatively simple blocks like edge detectors to very complex ones like real-time FFT blocks. Additionally, blocks for interfacing with hardware like ADCs, memory an generic IO are included. It was necessary for this project to update some blocks during this project, hence a clone of this mlib-devel repo was maintained\footnote{\url{https://github.com/jgowans/mlib_devel}}.

\section{Design}


\section{ADCs}
The ADCs which were available for use were the CASPER iADCs. 
These are 8-bit, dual core ADCs, where each core runs at \SI{800}{\mega\hertz}. The cores can either be interleaved to sample a single antenna at \SI{1600}{\mega\hertz} or 2 antennas at \SI{800}{\mega\hertz} each.

\section{Polyphase Filter Bank}
Consists of a polyphase FIR filter which applies a window to the input signal in order to prevent spectral leakage followed by a FFT block. FFT consumes most resources and thus some optimisations had to be done to it. 4K PFB. FFT was a real FFT block meaning it only outputs the upper half spectrum as the lower half is the same due to input signals being real. 

Shifting schedule set by software. Bit growth occurs at each stage. If the output of a stage is not shifted down by 1, it risks overflowing. However, if shifting is done unnecessarily, dynamic range is reduced as lower bits are thrown away. Algorithm coded to find optimal shifting. Discuss algorithm here.

\section{Cross Multiplier}
After the FFT, each antenna combination is multiplied together, one being the original signal and one being the complex conjugate. This is somewhat equivalent to dividing the complex numbers, where the key output is that the phase difference between the two antennas is produces. Some maths here to show that this is true. 

Optimisations done here: these are fairly large multiplier. Each pair of antennas requires an 18 bit multiplier for the real and imag components, for both simultanious channels. This means 4 18-bit multipliers for 10 combinations. 40 x 18-bit multipliers is a lot of hardware! 
To mitigate this, I made a change to the complex multiplier block to allow selecting of DSP48E for multipliers. This change was committed back into the centeral code repo for all to use.

Output of a 18\_17 x 18\_17 is a 37\_34. 

\section{Vector Accumulator}
The output vector (2K complex elements) is accumulated by summing each element. 
This is accumulated to a 48 bit number, hence allowing for substantial growth. 
This is key to getting a very good phase difference approximation as uncorrelated noise is integrated out. 
The vector accumulator is implemented by two DSP48E blocks, one for the real and one for the imag components. 
This is followed by a bram which stores and feeds back the vector to the DSP48E adder. 

The design is such that 48 bits are continuously accumulated. After the accumulation has run for a configurable number of iterations, the most significant 32 bits are sliced off and snapped. By accumulating 48 bits, no data is thrown away until the snap. Commit XXXXX makes this change to the dsp48\_bram\_vacc block in the casper library.

\section{Compiling the design}
This design was iterated on and compiled more than 100 times as functionality was added and experimentation was done.
The design is very large, using over 95\% of the available logic on the Virtex 5 FPGA. This has meant that it is a difficult design to compile, often failing to meet timing requirements.
Running at \SI{200}{\mega\hertz} means that a signal needs to get from the data source element to the data end element through any intermediate logic within \SI{5}{\nano\second}. 
There are two components to the propogartion time of a signal inside the FPGA. First is propogation delay through logic and the second is propogation delay through routing. When the design is very large, routing delay goes up as logic gets spread further apart on the chip. When there are lots of gates which a signal has to go through, logic delay goes up. 

The data signal needs to arrive at the data end element a short time before the clock signal, and it needs to remain valid for some short time after the clock edge. This first amount of time is known as setup time and the time after the edge is known as hold time. If the data propogration delay is too large, setup will not be met. If clock skew is too large, hold time will not be met.
When timing fails, Xilinx Sysgen reports which net has failed, between which source and end elements timing has failed, which logic blocks the data line passed through, where they are physically located on the FPGA, how much of the delay was caused by logic propagation and how much routing propagation. 

If the source and destination elements are far apart, timing will be dominated by routing. The designed may attempt to use tools like FloorPlanner to move the elements around on the chip to get them close together. For a design like this using about 90\% of the logic, there is almost no room to adjust and this becomes very challenging. 

Solution: inserting a dummy latch in the data path so that the data will be latched in somewhere between the original source and destination elements. This is essentially increasing the latency of the pipeline. This is not a easy solution though: often for logic constrained designed, adding a latch to a wide data pipeline will make even more data paths fail timing as there is not less logic available for optimizing logic placement. It's necessary to carefully consider exactly where and why timing is failing before attempting to fix. Trying to fix timing errors is painful and slow, considering that a compile can take over 2 hours before throwing a timing error. 

\input{./tex/52-firmware-frequency-correlations}
\input{./tex/55-impulse-capture}
\input{./tex/57-simulations}
\input{./tex/58-firmware-performance-measurements}
