\chapter{FPGA Firmware}
\label{ch:firmware-design}
\setsvg{svgpath=./img/firmware/}
\graphicspath{{./img/firmware/}}

This Chapter details the design, implementation and testing of the FPGA firmware. Testing involves both simulating using data path as well putting the firmware on the physical FPGA, sending input RF signals to it and analysing the output of the FPGA's DSP.

\section{Hardware Specifications}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{roach-photo}
  \caption{Photo of the ROACH board and ADCs. Bottom: Two Atmel AT84AD001B dual ADC cards with SMA connectors going in to them and connected via Z-DOK to the ROACH board. Bottom right: ADC clock synthesiser feeding into power splitter which in turn clocks each ADC board in phase. Top: main ROACH board. The Virtex-5 is under the blue fan. To its left is the ROACH's DRAM module. To the right of the fan is the PowerPC with its DRAM module.}
  \label{fig:firmware:roach-photo}
\end{figure}

As discussed in the user requirements, the FPGA processing board that should be use is the same which is used by the SKA: the Reconfigurable Open Architecture Computing Hardware (ROACH)\footnote{\url{https://casper.berkeley.edu/wiki/ROACH}} board. This board has a Xilinx Virtex-5 FPGA on it, with connectors for Z-DOK+ cards which will be used for ADCs and a DDR2 DRAM connector for high volume\footnote{Compared to the Virtex-5's on-chip storage} data storage. There is a PowerPC subsystem on the ROACH running Linux which provides a 1 Gbps Ethernet interface for programming and data readout from the memory of the FPGA. The PowerPC runs a daemon called tcpborphserver which speaks the KATCP protocol used to interact with the ROACH. There are other blocks on the ROACH board as well, but the ones listed here will be the ones utilised in this project.

There are various ADC cards compatible with the ROACH. The ones which were made available for this project are iADC cards. Each card has an Atmel/e2V AT84AD001B 8-bit dual ADC chip on it. It's designed for I/Q sampling but can be configured to sample both channels in phase; exactly what's needed here. The clock speed can be up to \SI{1}{\giga\hertz} and must be externally supplied. The ADC feeds the clock signal through to the FPGA along with the sampled data with a demux factor of 4:1 meaning that for every 4 ADC clock cycles and 4 samples, the FPGA gets one clock cycle with all 4 samples on the ADC data bus. This implies that the FPGA will run at exactly a quarter of the speed the ADC runs at, and needs to be able to handle 4 samples per channel times 4 channels = 16 samples every clock cycle.

The clock source is a Valon 5007 dual synthesiser which is USB programmable from \SI{137}{\mega\hertz} to \SI{4400}{\mega\hertz}. Both ADCs need to be clocked exactly in phase so the Valon is fed into a Mini-Circuits ZESC2-11+ power splitter which has a low phase imbalance.

The ROACH board with connected ADCs is shown in \Cref{fig:firmware:roach-photo}. All of the components are in a metal case for RF shielding, although the cover has been removed for the photo.


\section{Firmware Development Toolchain}
There are a few components necessary to get development for the ROACH working. They're briefly listed here and detailed more in \Cref{appendix:roach-development}.\\

Xilinx ISE 14.7 is needed for synthesising (compiling) HDL files to FPGA bitfiles. This proprietary tools is maintained by Xilinx and made available through the SKA. As well as this key task of compilation it also has peripheral tools for debugging and optimisation which proved useful for getting the design to meet timing. More info in \Cref{appendix:roach-development}. Although it also works on Debian/Ubuntu systems, ISE is most stable and only officially supported for RHEL. As such as CentOS system was used for FPGA development work as it's mostly the same as RHEL at the binary interface level.\\

Matlab R2012B with Simulink was installed, along  with the mlib-devel plugin. The majority of the design work for ROACH done in this project is done at the block diagram level in Simulink. There is a plugin called mlib-devel which defines the Simulink interface for the Xilinx cores, as well as containing HDL code for ROACH specific hardware such as ADC cards, DRAM interface and PowerPC control bus. This naturally includes the net definitions for the components on the ROACH board.

The mlib-devel plugin was originally created by CASPER, now contributed to extensively by the SKA. It contains a multitude of highly useful DSP blocks which are built on top of the Xilinx cores which can be wired up in Simulink. These include range from relatively simple blocks like edge detectors to very complex ones like real-time FFT blocks and polyphase filterbank blocks. Additionally, blocks for interfacing with hardware like ADCs, memory, shared registered and generic IO are included. It was necessary for this project to update some blocks during this project, hence a clone of this mlib-devel repo was created\footnote{\url{https://github.com/jgowans/mlib_devel}}.


\section{Design}
There are a number of subsystems developed for the FPGA which will be discussed here. Most of these subsystems required extensive development, testing and tweaking. The full design is shown in \Cref{fig:firmware:full-design}. It may be difficult to see all of the detail of the design, but the purpose of the figure is to give an indication of the structure, layout and data flow in the FPGA. The following subsections discuss the purpose of the key blocks in the design. A more detailed look at the composition and structure of the some of the blocks can be found in \Cref{appendix:roach-development}. That Appendix also discusses the challenges that were encountered during the FPGA design, and the optimisations that were done to get it working.

\afterpage{%
  \clearpage% 
  \begin{landscape}
    \thispagestyle{empty}
    \begin{figure}
      \vspace{-4em}
      \centering
      \makebox[\textwidth][c] {
        \includegraphics[width=1.22\paperwidth,center]{full-design-a4-no-sim-out.pdf}%
      }%
      \caption{Full FPGA design containing frequency and time DSP paths and control logic.}
      \label{fig:firmware:full-design}
    \end{figure}
  \end{landscape}
}

\subsection{ADCs}
The yellow blocks on the left represent the two dual ADCs. These \(2 \times 2\) channels will be referred to as channel 0, 1, 2 and 3. Each ADC has \(2 \times 4 = 8\) 8-bit buses for the signed integer samples that are clocked in every clock cycle. As mentioned earlier the FPGA runs at a quarter of the ADC clock cycle hence the ADC presents 4 samples per clock cycle.  Also included are logic lines that indicate clipping. For simulation purposes, normal Simulink signal source blocks can be connected to the ADC, allowing the construction of arbitrarily complex input signals. The example shows a simple chirp connected. The output from the ADCs fans out to two distinct signals paths: a frequency domain path and a time domain path. These are now explored.

\subsection{Frequency domain signal path}
The frequency domain path starts with an FFT block, the first big green one,  which performs real time FFTs on the data from the ADCs. Although it's one block it does four distinct Fourier transforms under the hood, one for each of the ADC channels. It's an 11 stage FFT meaning that it does \(2^{11} = 2048\) points. It has an optimisation for real-valued signals in that it only output the positive half of the frequency spectrum to save bandwidth. The FFT has been configured to do full bit growth, meaning that every stage another bit of data is added to the bus size. This means that weak signals will be preserved as no bits are thrown away. This is at the expense of significant data growth: each channel outputs two 36-bit complex numbers every clock cycle.

FFT output is fed into the second big green block, the Cross Multiplier. This does \({4 \choose 2} = 6\) cross multiplications, one for each visibility, as well as one additional for the autocorrelation of channel 0 to serve as a spectrum analyser. These are referred to as 0x0, 0x1, 0x2, 0x3, 1x2, 1x3 and 2x3. The cross multiplication involves breaking the signal up into its real and imaginary component, taking the complex conjugate of one of the signals by inverting the sign of its complex component and then doing complex multiplication. For each two signals \(A = (a + ib)\) and \(B = (c + id)\) the FPGA will do \(Z = X\overline{Y} = (ac + bd) + (bc - ad)i\). The cross multiplier does not throw any bits away meaning that the signals go from a \(2 \times 36 = 72\) bit complex numbers to 148 bits per channel.

The cross correlation signals then go to the white Accumulators block. As discussed in Chapter 3, the cross correlations will be accumulated (aka: integrated) a number of times in order to allow weak signals to stand out of the noise. The accumulation length is runtime programmable via a control register which will be discussed more later. The accumulator works by using FPGA BRAM to produce a delay, and a DSP48E to add the new signal to the current one. The length of the BRAM is the number of points in the FFT spectrum, 2048. The accumulators allow signal growth from 74 bits per complex number to 96 bits. This implies a minimum of \(\approx 4\) million accumulations when the signals are full scale, although typically this can be orders of magnitude more as the system does not run with full scale input; it's too dangerous the keep the ADCs at max power.

Each accumulated correlation value is wired to its own BRAM snapshot block, the array of small green blocks on the right. Once sufficient accumulations have been run, the snapshot blocks are triggered to take a snapshot of the correlation spectrums. The snapshots then record the full accumulated correlation spectrum of a channel, now 128 bits wide per frequency channel per correlation pair, to shared BRAM memory. This memory can then be read out from the FPGA via the PowerPC over Ethernet.

\subsection{Time domain signal path}
This path is comparatively simpler than the frequency domain path, seeing as the correlations are not being done on the FPGA, and seeing as accumulation is not applicable for time domain DF. 

There are two main blocks for the time domain path, which are at the bottom of the FPGA design. First is the impulse detector. This takes in the raw ADC data from channel 0 and runs a rolling sum filter which provides the sum of the last \(N\) samples where \(N\) is some runtime programmable number, typically between 10 and 1000 samples. If the rolling sum goes above a runtime programmable threshold the impulse detector considers an impulse to be present. It then records the raw time domain data of all 4 channels for as long as the impulse is present, plus some additional buffer at the start and end of the pulse.  The snapshot is stored by the green block at the bottom, the off-chip DRAM module. The starting buffer is attained by feeding a delayed version of the raw signal to the DRAM interface. The DRAM module was chosen as it can store a large amount of data, allowing multiple milliseconds of raw data to be stored if desired. Typically only a few microseconds of data is necessary to store an impulsive signal. As well as triggering the snapshot, the impulse detector will also store the length of the impulse which it detected so that the computer knows much data to read out from the DRAM module when it wants the data. The DRAM data is also accessible through the PowerPC over Ethernet.

\subsection{Control and Monitoring}
Foo.



\section{Compiling the design}
This design was iterated on and compiled more than 100 times as functionality was added and experimentation was done.
The design is very large, using over 95\% of the available logic on the Virtex 5 FPGA. This has meant that it is a difficult design to compile, often failing to meet timing requirements.
Running at \SI{200}{\mega\hertz} means that a signal needs to get from the data source element to the data end element through any intermediate logic within \SI{5}{\nano\second}. 
There are two components to the propogartion time of a signal inside the FPGA. First is propogation delay through logic and the second is propogation delay through routing. When the design is very large, routing delay goes up as logic gets spread further apart on the chip. When there are lots of gates which a signal has to go through, logic delay goes up. 

The data signal needs to arrive at the data end element a short time before the clock signal, and it needs to remain valid for some short time after the clock edge. This first amount of time is known as setup time and the time after the edge is known as hold time. If the data propogration delay is too large, setup will not be met. If clock skew is too large, hold time will not be met.
When timing fails, Xilinx Sysgen reports which net has failed, between which source and end elements timing has failed, which logic blocks the data line passed through, where they are physically located on the FPGA, how much of the delay was caused by logic propagation and how much routing propagation. 

If the source and destination elements are far apart, timing will be dominated by routing. The designed may attempt to use tools like FloorPlanner to move the elements around on the chip to get them close together. For a design like this using about 90\% of the logic, there is almost no room to adjust and this becomes very challenging. 

Solution: inserting a dummy latch in the data path so that the data will be latched in somewhere between the original source and destination elements. This is essentially increasing the latency of the pipeline. This is not a easy solution though: often for logic constrained designed, adding a latch to a wide data pipeline will make even more data paths fail timing as there is not less logic available for optimizing logic placement. It's necessary to carefully consider exactly where and why timing is failing before attempting to fix. Trying to fix timing errors is painful and slow, considering that a compile can take over 2 hours before throwing a timing error. 

\input{./tex/52-firmware-frequency-correlations}
\input{./tex/55-impulse-capture}
\input{./tex/57-simulations}
\input{./tex/58-firmware-performance-measurements}
